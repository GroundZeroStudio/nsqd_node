    

nsqd解析:nsqd\_protocolV2
=======================
[](about:blank#protocol-v2-%E5%8D%8F%E8%AE%AE "protocol_v2 协议")protocol\_v2 协议
==============================================================================

  一个客户端只能订阅一个 channel,客户端可以向 nsqd 发送指令完成指定操作并返回结果,nsqd 可以向客户端推送消息.


[](about:blank#IOLoop-%E6%93%8D%E4%BD%9C "IOLoop 操作")IOLoop 操作
--------------------------------------------------------------

  从上一节我们了解到,nsqd 每和一个客户端建立 TCP 连接都会创建一个 protocolV2 struct,里面仅仅包含所处语境即 nsqd,然后执行 IOLoop 操作进行 nsqd 和客户端的通信.所以只需要从 IOLoop 入手便可以一览 nsqd 与客户端之间的消息处理:

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立连接后的进行 IOLoop 操作,接收消息,每一个客户端 TCP 连接对应一个 protocolV2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *protocolV2)</span> <span class="title">IOLoop</span><span class="params">(conn net.Conn)</span> <span class="title">error</span></span> {</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">var</span> line []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">var</span> zeroTime time.Time</span><br><span class="line">	<span class="comment">// 获取一个 ClientID</span></span><br><span class="line">	clientID := atomic.AddInt64(&amp;p.ctx.nsqd.clientIDSequence, <span class="number">1</span>)</span><br><span class="line">	<span class="comment">// 创建一个 client 用来代理这个客户端</span></span><br><span class="line">	client := newClientV2(clientID, conn, p.ctx)</span><br><span class="line">	<span class="comment">// 将这个客户端添加到 nsqd 中进行管理</span></span><br><span class="line">	p.ctx.nsqd.AddClient(client.ID, client)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 首先创建一个 messagePumpStartedChan channel,并把它传入到 messagePump 中</span></span><br><span class="line">	<span class="comment">// 下面阻塞在从 messagePumpStartedChan 中获取消息,但其实这个 channel 在 messagePump 中关闭了</span></span><br><span class="line">	<span class="comment">// 这是为了保证让 IOLoop 中的 for 循环和 messagePump 中的 for 循环同步运行.</span></span><br><span class="line">	<span class="comment">// IOLoop 中的 for 循环时接收客户端的请求并进行解析,处理请求,最后给客户端响应.</span></span><br><span class="line">	<span class="comment">// messagePump 中的 for 循环会从内存和 disk 中获取准备好的 message 返回给客户.</span></span><br><span class="line">	<span class="comment">// 如果不添加 messagePumpStartedChan 一般会导致 IOLoop 中的 for 循环先执行,但是 messagePump 还没有准备好</span></span><br><span class="line">	messagePumpStartedChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> p.messagePump(client, messagePumpStartedChan)</span><br><span class="line">	&lt;-messagePumpStartedChan</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> {</span><br><span class="line">		<span class="comment">// 根据心跳间隔设置 ReadDeadline 时间</span></span><br><span class="line">		<span class="keyword">if</span> client.HeartbeatInterval &gt; <span class="number">0</span> {</span><br><span class="line">			client.SetReadDeadline(time.Now().Add(client.HeartbeatInterval * <span class="number">2</span>))</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			client.SetReadDeadline(zeroTime)</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 读取一个指令</span></span><br><span class="line">		line, err = client.Reader.ReadSlice(<span class="string">'\n'</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF {</span><br><span class="line">				err = <span class="literal">nil</span></span><br><span class="line">			} <span class="keyword">else</span> {</span><br><span class="line">				err = fmt.Errorf(<span class="string">"failed to read command - %s"</span>, err)</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 删除指令末尾的 '\n'</span></span><br><span class="line">		line = line[:<span class="built_in">len</span>(line)<span class="number">-1</span>]</span><br><span class="line">		<span class="comment">// 可能还需要修剪一下 '\r'</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(line) &gt; <span class="number">0</span> &amp;&amp; line[<span class="built_in">len</span>(line)<span class="number">-1</span>] == <span class="string">'\r'</span> {</span><br><span class="line">			line = line[:<span class="built_in">len</span>(line)<span class="number">-1</span>]</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">// 按照空格进行划分</span></span><br><span class="line">		params := bytes.Split(line, separatorBytes)</span><br><span class="line"></span><br><span class="line">		p.ctx.nsqd.logf(LOG_DEBUG, <span class="string">"PROTOCOL(V2): [%s] %s"</span>, client, params)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> response []<span class="keyword">byte</span></span><br><span class="line">		<span class="comment">// 执行客户端对应的操作,✨✨✨</span></span><br><span class="line">		response, err = p.Exec(client, params)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">			ctx := <span class="string">""</span></span><br><span class="line">			<span class="keyword">if</span> parentErr := err.(protocol.ChildErr).Parent(); parentErr != <span class="literal">nil</span> {</span><br><span class="line">				ctx = <span class="string">" - "</span> + parentErr.Error()</span><br><span class="line">			}</span><br><span class="line">			p.ctx.nsqd.logf(LOG_ERROR, <span class="string">"[%s] - %s%s"</span>, client, err, ctx)</span><br><span class="line">			<span class="comment">// 将错误发送给客户端</span></span><br><span class="line">			sendErr := p.Send(client, frameTypeError, []<span class="keyword">byte</span>(err.Error()))</span><br><span class="line">			<span class="keyword">if</span> sendErr != <span class="literal">nil</span> {</span><br><span class="line">				p.ctx.nsqd.logf(LOG_ERROR, <span class="string">"[%s] - %s%s"</span>, client, sendErr, ctx)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="comment">// FatalClientErr 类型的错误应关闭连接</span></span><br><span class="line">			<span class="keyword">if</span> _, ok := err.(*protocol.FatalClientErr); ok {</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		}</span><br><span class="line">		<span class="comment">// 将执行后的结果返回给客户端</span></span><br><span class="line">		<span class="keyword">if</span> response != <span class="literal">nil</span> {</span><br><span class="line">			err = p.Send(client, frameTypeResponse, response)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">				err = fmt.Errorf(<span class="string">"failed to send response - %s"</span>, err)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 退出循环</span></span><br><span class="line">	p.ctx.nsqd.logf(LOG_INFO, <span class="string">"PROTOCOL(V2): [%s] exiting ioloop"</span>, client)</span><br><span class="line">	conn.Close()</span><br><span class="line">	<span class="comment">// 关闭 client 的所有监听 goroutine</span></span><br><span class="line">	<span class="built_in">close</span>(client.ExitChan)</span><br><span class="line">	<span class="keyword">if</span> client.Channel != <span class="literal">nil</span> {</span><br><span class="line">		<span class="comment">// 如果客户端监听的 channel 不为空,从 channel 移除这个客户端</span></span><br><span class="line">		client.Channel.RemoveClient(client.ID)</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 从 nsqd 移除这个客户端</span></span><br><span class="line">	p.ctx.nsqd.RemoveClient(client.ID)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">}</span><br></pre></td></tr></tbody></table>

这个函数是用来从客户端接收指令并进行处理,主要工作有:

1.  创建一个 client 用来管理客户端
2.  启动 goroutine 执行 messagePump,并阻塞等待 messagePump 中的 for 同步运行
3.  在一个 for 循环中不断处理客户端传过来的指令,并将处理结果进行返回

[](about:blank#messagePump-%E6%93%8D%E4%BD%9C "messagePump 操作")messagePump 操作
=============================================================================

  和 IOLoop 同步执行的还有 messagePump,是用来将内存和 disk 中获取准备好的 message 返回给客户.

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *protocolV2)</span> <span class="title">messagePump</span><span class="params">(client *clientV2, startedChan <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> {</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="comment">// 从内存获取消息的通道</span></span><br><span class="line">	<span class="keyword">var</span> memoryMsgChan <span class="keyword">chan</span> *Message</span><br><span class="line">	<span class="comment">// 从磁盘获取消息的通道</span></span><br><span class="line">	<span class="keyword">var</span> backendMsgChan <span class="keyword">chan</span> []<span class="keyword">byte</span></span><br><span class="line">	<span class="comment">// 订阅的频道</span></span><br><span class="line">	<span class="keyword">var</span> subChannel *Channel</span><br><span class="line">	<span class="comment">// 解决消息延迟的问题,强制刷新</span></span><br><span class="line">	<span class="keyword">var</span> flusherChan &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line">	<span class="keyword">var</span> sampleRate <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">	subEventChan := client.SubEventChan</span><br><span class="line">	identifyEventChan := client.IdentifyEventChan</span><br><span class="line">	outputBufferTicker := time.NewTicker(client.OutputBufferTimeout)</span><br><span class="line">	heartbeatTicker := time.NewTicker(client.HeartbeatInterval)</span><br><span class="line">	heartbeatChan := heartbeatTicker.C</span><br><span class="line">	msgTimeout := client.MsgTimeout</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用来强制刷新消息给客户端,两种情况不会进行强制刷新:</span></span><br><span class="line">	<span class="comment">// 1. 客户端没有准备好接收消息</span></span><br><span class="line">	<span class="comment">// 2. buffer 中没有消息,怎么刷都没用</span></span><br><span class="line">	flushed := <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通知 IOLoop 开始执行</span></span><br><span class="line">	<span class="built_in">close</span>(startedChan)</span><br></pre></td></tr></tbody></table>

  到这里 messagePump 的准备工作就已经做完了,最后 close startedChan 同时启动 IOLoop 和 messagePump 中的 for 循环

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> {</span><br><span class="line">	<span class="keyword">if</span> subChannel == <span class="literal">nil</span> || !client.IsReadyForMessages() {</span><br><span class="line">		<span class="comment">// 客户端暂时还不能接收消息</span></span><br><span class="line">		memoryMsgChan = <span class="literal">nil</span></span><br><span class="line">		backendMsgChan = <span class="literal">nil</span></span><br><span class="line">		<span class="comment">// 不允许强制刷消息给客户端</span></span><br><span class="line">		flusherChan = <span class="literal">nil</span></span><br><span class="line">		<span class="comment">// 强制刷新客户端</span></span><br><span class="line">		client.writeLock.Lock()</span><br><span class="line">		err = client.Flush()</span><br><span class="line">		client.writeLock.Unlock()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">			<span class="keyword">goto</span> exit</span><br><span class="line">		}</span><br><span class="line">	</span><br><span class="line">		flushed = <span class="literal">true</span></span><br><span class="line">	} <span class="keyword">else</span> <span class="keyword">if</span> flushed {</span><br><span class="line">		<span class="comment">// channel 中不是很堵,暂时关闭强制刷新,仅接收 channel 内存通道和磁盘通道即可</span></span><br><span class="line">		memoryMsgChan = subChannel.memoryMsgChan</span><br><span class="line">		backendMsgChan = subChannel.backend.ReadChan()</span><br><span class="line">		flusherChan = <span class="literal">nil</span></span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		<span class="comment">// channel 中有大消息,打开强制刷新定时器</span></span><br><span class="line">		memoryMsgChan = subChannel.memoryMsgChan</span><br><span class="line">		backendMsgChan = subChannel.backend.ReadChan()</span><br><span class="line">		flusherChan = outputBufferTicker.C</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table>

  在这个 for 循环中,每次开始执行 select 之前需要先对客户端的情况进行判断,有如下三种情况:

1.  客户端没有订阅 channel 或者客户端还没有准备好接收消息,在 select 中等待 subEventChan 和 ReadyStateChan 的消息,用来加载 客户端订阅的 channel 消息通道和知晓客户端已经准备好接受消息.
2.  客户端可以接受消息,但是 channel 中已经没有消息了,不需要开启强制刷新,仅从 channel 的两个通道中正常获取消息即可
3.  客户端可以接收消息,并且 channel 中有很多消息等待投递,可以打开 flusherChan 进行手动刷新

  这里处理初始化时属于第一种情况,订阅 channel 后就一直在 2,3 之间进行切换.是怎么判断 channel 的通道中是否有消息需要进行强制刷新呢?如果从内存通道中获取消息就表示目前 channel 情况还正常,一旦开始从 backend 中获取消息就表示 channel 中已经积压了大量的消息,需要打开强制刷新.默认刷新频率为:250ms,通过强制刷新把 client 写缓冲区中的消息推送给客户端,让 client 可以更快的从 channel 中获取消息

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">select</span> {</span><br><span class="line">	<span class="keyword">case</span> &lt;-flusherChan:</span><br><span class="line">		<span class="comment">// 强制刷新 client 的写缓冲区</span></span><br><span class="line">		client.writeLock.Lock()</span><br><span class="line">		err = client.Flush()</span><br><span class="line">		client.writeLock.Unlock()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">			<span class="keyword">goto</span> exit</span><br><span class="line">		}</span><br><span class="line">		flushed = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-client.ReadyStateChan:</span><br><span class="line">	<span class="keyword">case</span> subChannel = &lt;-subEventChan:</span><br><span class="line">		<span class="comment">// 仅订阅一次 channel 之后即使调用 SUB 也不会切换频道</span></span><br><span class="line">		subEventChan = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> identifyData := &lt;-identifyEventChan:</span><br><span class="line">		<span class="comment">// 验证确认客户端,仅触发一次</span></span><br><span class="line">		<span class="comment">// 就是设置各种触发间隔</span></span><br><span class="line">		identifyEventChan = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">		outputBufferTicker.Stop()</span><br><span class="line">		<span class="keyword">if</span> identifyData.OutputBufferTimeout &gt; <span class="number">0</span> {</span><br><span class="line">			outputBufferTicker = time.NewTicker(identifyData.OutputBufferTimeout)</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		heartbeatTicker.Stop()</span><br><span class="line">		heartbeatChan = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> identifyData.HeartbeatInterval &gt; <span class="number">0</span> {</span><br><span class="line">			heartbeatTicker = time.NewTicker(identifyData.HeartbeatInterval)</span><br><span class="line">			heartbeatChan = heartbeatTicker.C</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> identifyData.SampleRate &gt; <span class="number">0</span> {</span><br><span class="line">			sampleRate = identifyData.SampleRate</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		msgTimeout = identifyData.MsgTimeout</span><br><span class="line">	<span class="keyword">case</span> &lt;-heartbeatChan:</span><br><span class="line">		<span class="comment">// 发送心跳消息给客户端</span></span><br><span class="line">		err = p.Send(client, frameTypeResponse, heartbeatBytes)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">			<span class="keyword">goto</span> exit</span><br><span class="line">		}</span><br><span class="line">	<span class="keyword">case</span> b := &lt;-backendMsgChan:  <span class="comment">// 从 channel 磁盘消息缓冲区中接收消息</span></span><br><span class="line">		<span class="keyword">if</span> sampleRate &gt; <span class="number">0</span> &amp;&amp; rand.Int31n(<span class="number">100</span>) &gt; sampleRate {</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		}</span><br><span class="line">		<span class="comment">// 先 decode 消息</span></span><br><span class="line">		msg, err := decodeMessage(b)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">			p.ctx.nsqd.logf(LOG_ERROR, <span class="string">"failed to decode message - %s"</span>, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		}</span><br><span class="line">		msg.Attempts++</span><br><span class="line">		<span class="comment">// 放进到待确认列表并发送给客户端</span></span><br><span class="line">		subChannel.StartInFlightTimeout(msg, client.ID, msgTimeout)</span><br><span class="line">		client.SendingMessage()</span><br><span class="line">		err = p.SendMessage(client, msg)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">			<span class="keyword">goto</span> exit</span><br><span class="line">		}</span><br><span class="line">		flushed = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">case</span> msg := &lt;-memoryMsgChan:  <span class="comment">// 从 channel 内存消息缓冲区中接收消息</span></span><br><span class="line">		<span class="keyword">if</span> sampleRate &gt; <span class="number">0</span> &amp;&amp; rand.Int31n(<span class="number">100</span>) &gt; sampleRate {</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		}</span><br><span class="line">		msg.Attempts++</span><br><span class="line">		<span class="comment">// 添加到待确认列表并发送给客户端</span></span><br><span class="line">		subChannel.StartInFlightTimeout(msg, client.ID, msgTimeout)</span><br><span class="line">		client.SendingMessage()</span><br><span class="line">		err = p.SendMessage(client, msg)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">			<span class="keyword">goto</span> exit</span><br><span class="line">		}</span><br><span class="line">		flushed = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-client.ExitChan:</span><br><span class="line">		<span class="comment">// 退出循环</span></span><br><span class="line">		<span class="keyword">goto</span> exit</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table>

整个阻塞在 select 有 8 种情况:

1.  强制刷新消息给客户端
2.  客户端准备就绪等待接收消息
3.  客户端订阅频道,加载 channel 消息接收列表(仅能订阅一次 channel)
4.  验证链接时执行的操作,设置消息循环的各种定时器间隔(只可以确认一次)
5.  给客户端发送心跳消息
6.  从磁盘队列接收消息
7.  从内存队列接收消息
8.  退出 messagePump
    
    <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">exit:</span><br><span class="line">	p.ctx.nsqd.logf(LOG_INFO, <span class="string">"PROTOCOL(V2): [%s] exiting messagePump"</span>, client)</span><br><span class="line">	heartbeatTicker.Stop()</span><br><span class="line">	outputBufferTicker.Stop()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		p.ctx.nsqd.logf(LOG_ERROR, <span class="string">"PROTOCOL(V2): [%s] messagePump error - %s"</span>, client, err)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table>
    

  收尾工作就是停止几个定时器并退出即可.在 messagePump 中获取了消息之后会调用 SendMessage 来吧消息发送给客户端:

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *protocolV2)</span> <span class="title">SendMessage</span><span class="params">(client *clientV2, msg *Message)</span> <span class="title">error</span></span> {</span><br><span class="line">	<span class="keyword">var</span> buf = &amp;bytes.Buffer{}</span><br><span class="line">	<span class="comment">// 消息放到 buf 中</span></span><br><span class="line">	_, err := msg.WriteTo(buf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 调用 Send 发送</span></span><br><span class="line">	err = p.Send(client, frameTypeMessage, buf.Bytes())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 向 client 发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *protocolV2)</span> <span class="title">Send</span><span class="params">(client *clientV2, frameType <span class="keyword">int32</span>, data []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">	client.writeLock.Lock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> zeroTime time.Time</span><br><span class="line">	<span class="comment">// 写超时设置</span></span><br><span class="line">	<span class="keyword">if</span> client.HeartbeatInterval &gt; <span class="number">0</span> {</span><br><span class="line">		client.SetWriteDeadline(time.Now().Add(client.HeartbeatInterval))</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		client.SetWriteDeadline(zeroTime)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	_, err := protocol.SendFramedResponse(client.Writer, frameType, data)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		client.writeLock.Unlock()</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// frameTypeMessage : 发送给客户端的消息立即刷新</span></span><br><span class="line">	<span class="comment">// frameTypeResponse : 客户端指令返回不会立即刷新</span></span><br><span class="line">	<span class="keyword">if</span> frameType != frameTypeMessage {</span><br><span class="line">		err = client.Flush()</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	client.writeLock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">}</span><br></pre></td></tr></tbody></table>

  nsqd 对每个客户端使用两个 gououtine 分别执行 IOLoop 和 messagePump 就完成了二者之间的指令和消息传递.代码很容易理清楚.

[](about:blank#protocol-v2-%E4%B8%AD%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E6%8C%87%E4%BB%A4 "protocol_v2 中客户端的指令")protocol\_v2 中客户端的指令
=====================================================================================================================================

[](about:blank#Exec "Exec")Exec
-------------------------------

  在 IOLoop 中,没收到客户端传来的一条指令,都会解析完成后,通过 Exec 进行执行.判断指令的类型然后调用对应的函数执行即可.

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行客户端传递过来的指令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *protocolV2)</span> <span class="title">Exec</span><span class="params">(client *clientV2, params [][]<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> {</span><br><span class="line">	<span class="comment">// 认证一个客户端</span></span><br><span class="line">	<span class="keyword">if</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"IDENTIFY"</span>)) {</span><br><span class="line">		<span class="keyword">return</span> p.IDENTIFY(client, params)</span><br><span class="line">	}</span><br><span class="line">	err := enforceTLSPolicy(client, p, params[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">switch</span> {</span><br><span class="line">	<span class="comment">// 确认收到一条消息</span></span><br><span class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"FIN"</span>)):</span><br><span class="line">		<span class="keyword">return</span> p.FIN(client, params)</span><br><span class="line">	<span class="comment">// 指定可同时处理的消息数量</span></span><br><span class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"RDY"</span>)):</span><br><span class="line">		<span class="keyword">return</span> p.RDY(client, params)</span><br><span class="line">	<span class="comment">// 消息重新加入 channel 发送</span></span><br><span class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"REQ"</span>)):</span><br><span class="line">		<span class="keyword">return</span> p.REQ(client, params)</span><br><span class="line">	<span class="comment">// 向 topic 推送一条消息</span></span><br><span class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"PUB"</span>)):</span><br><span class="line">		<span class="keyword">return</span> p.PUB(client, params)</span><br><span class="line">	<span class="comment">// 向 topic 推送多条消息</span></span><br><span class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"MPUB"</span>)):</span><br><span class="line">		<span class="keyword">return</span> p.MPUB(client, params)</span><br><span class="line">	<span class="comment">// 向 topic 推送一条延迟消息</span></span><br><span class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"DPUB"</span>)):</span><br><span class="line">		<span class="keyword">return</span> p.DPUB(client, params)</span><br><span class="line">	<span class="comment">// 不作处理</span></span><br><span class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"NOP"</span>)):</span><br><span class="line">		<span class="keyword">return</span> p.NOP(client, params)</span><br><span class="line">	<span class="comment">// 重置一个待确认消息的超时时间</span></span><br><span class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"TOUCH"</span>)):</span><br><span class="line">		<span class="keyword">return</span> p.TOUCH(client, params)</span><br><span class="line">	<span class="comment">// 订阅一个 channel</span></span><br><span class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"SUB"</span>)):</span><br><span class="line">		<span class="keyword">return</span> p.SUB(client, params)</span><br><span class="line">	<span class="comment">// 关闭客户端</span></span><br><span class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"CLS"</span>)):</span><br><span class="line">		<span class="keyword">return</span> p.CLS(client, params)</span><br><span class="line">	<span class="comment">// 授权一个客户端</span></span><br><span class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"AUTH"</span>)):</span><br><span class="line">		<span class="keyword">return</span> p.AUTH(client, params)</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(<span class="literal">nil</span>, <span class="string">"E_INVALID"</span>, fmt.Sprintf(<span class="string">"invalid command %s"</span>, params[<span class="number">0</span>]))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table>

  这里的各个指令,基本都是先确认参数,然后调用对应的方法即可,不过多介绍,简单了解一下对应的含义及可:

| 指令 | 例子 | 操作 | 执行的操作 |
| --- | --- | --- | --- |
| FIN | FIN MessageID | 确认收到一条消息 | topic.FinishMessage |
| RDY | RDY count | 指定可同时处理的消息数量 | client.SetReadyCount |
| REQ | REQ messageID timeoutMs | 消息重新加入 channel 发送 | client.Channel.RequeueMessage |
| PUB | PUB topicName message | 向 topic 推送一条消息 | topic.PutMessage |
| MPUB | MPUB topicName messages | 向 topic 推送多条消息 | topic.PutMessages |
| DPUB | MPUB topicName timeoutMs message | 向 topic 推送一条延迟消息 | topic.PutMessage |
| NOP | NOP | 无效指令 | 不做处理 |
| TOUCH | TOUCH messageID | 重置一个待确认消息的超时时间 | client.Channel.TouchMessage |
| SUB | SUB topicName channelName | 订阅一个 channel | client.SubEventChan <- channel 触发消息循环 |
| CLS | CLS | 关闭客户端 | client.StartClose |
| AUTH | AUTH body | 授权一个客户端 | client.Auth |
| IDENTIFY | IDENTIFY body | 认证一个客户端 | client.Identify |

这里面比较特别的是 IDENTIFY 和 AUTH 两个操作.  
  client 和 nsqd 建立连接后,client 立即通过命令 IDENTIFY 将认证信息发给 nsqd,如果 nsqd 在启动的时候指定了授权地址,nsqd 就会告诉 client 你需要认证,client 就会通过命令 AUTH 将秘钥发给 nsqd,nsqd 去授权地址进行验证,验证通过后,就可以进行正常的消息发布和订阅了

[](about:blank#%E5%B0%8F%E7%BB%93 "小结")小结
=========================================

  整个协议的流程基本看完了,其实说起来就是通过 IOLoop 和 messagePump 进行 nsqd 和 client 的通信:

*   IOLoop 负责让 nsqd 执行 client 传过来的指令
*   messagePump 给客户端推送消息
